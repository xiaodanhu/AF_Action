import os
# os.environ["CUDA_DEVICE_ORDER"]="PCI_BUS_ID"   
# os.environ["CUDA_VISIBLE_DEVICES"]='1'
# python imports
import argparse
import os
import time
from datetime import datetime
import pprint

import math

# torch imports
import torch
import torch.nn as nn
import torch.utils.data
# for visualization
import json
import torch.distributed as dist
from torch.utils.data import DataLoader, DistributedSampler
import deepspeed

# our code
from libs.core import load_config
from libs.datasets import make_dataset, make_data_loader, make_data_loader_distributed
from libs.modeling import make_meta_arch
from libs.utils import (train_one_epoch, valid_one_epoch, ANETdetection,
                        save_checkpoint, make_optimizer, make_scheduler,
                        fix_random_seed, ModelEma, TrainingLogger)
import warnings
warnings.filterwarnings("ignore")


################################################################################
def main(args):
    """main function that handles training / inference"""

    torch.cuda.set_device(args.local_rank)
    device = torch.device("cuda", args.local_rank)
    deepspeed.init_distributed()
    
    with open("configs/deepspeed_config.json", 'r') as f:
        ds_config = json.load(f)

    """1. setup parameters / folders"""
    # parse args
    args.start_epoch = 0
    if os.path.isfile(args.config):
        cfg = load_config(args.config)
    else:
        raise ValueError("Config file does not exist.")

    # prep for output folder (based on time stamp)
    if not os.path.exists(cfg['output_folder']) and args.local_rank == 0:
        os.mkdir(cfg['output_folder'])
    cfg_filename = os.path.basename(args.config).replace('.yaml', '')
    ts = datetime.fromtimestamp(int(time.time()))
    if len(args.output) == 0:
        ckpt_folder = os.path.join(
            cfg['output_folder'], cfg_filename + '_' + str(ts))
    else:
        ckpt_folder = os.path.join(
            cfg['output_folder'], cfg_filename + '_' + str(args.output))
    if not os.path.exists(ckpt_folder) and args.local_rank == 0:
        os.mkdir(ckpt_folder)

    # fix the random seeds (this will fix everything)
    rng_generator = fix_random_seed(cfg['init_rand_seed'], include_cuda=True)

    # re-scale learning rate / # workers based on number of GPUs
    cfg['opt']["learning_rate"] *= len(cfg['devices'])
    cfg['loader']['num_workers'] *= len(cfg['devices'])

    """2. create dataset / dataloader"""
    train_dataset = make_dataset(
        cfg['dataset_name'], True, cfg['train_split'], cfg['model']['backbone_type'], cfg['round'], **cfg['dataset']
    )
    # update cfg based on dataset attributes (fix to epic-kitchens)
    train_db_vars = train_dataset.get_attributes()
    cfg['model']['train_cfg']['head_empty_cls'] = train_db_vars['empty_label_ids']

    # data loaders
    train_sampler = DistributedSampler(train_dataset, shuffle=True)
    train_sampler_for_test = DistributedSampler(train_dataset, shuffle=False)
    train_loader = make_data_loader_distributed(train_dataset, train_sampler, True, rng_generator, **cfg['loader'])
    train_loader_for_test = make_data_loader_distributed(train_dataset, train_sampler_for_test, False, None, 1, cfg['loader']['num_workers'])

    val_dataset = make_dataset(
        cfg['dataset_name'], False, cfg['val_split'], cfg['model']['backbone_type'], cfg['round'], **cfg['dataset']
    )
    # set bs = 1, and disable shuffle
    val_loader = make_data_loader(val_dataset, False, None, 1, cfg['loader']['num_workers'])
    
    """3. create model, optimizer, and scheduler"""
    # model
    cfg['model']['active_learning_method'] = cfg['active_learning_method']
    model = make_meta_arch(cfg['model_name'], **cfg['model'])
    # not ideal for multi GPU training, ok for now
    # model = nn.DataParallel(model, device_ids=cfg['devices'])
    parameters = filter(lambda p: p.requires_grad, model.parameters())
    # optimizer
    optimizer = make_optimizer(model, cfg['opt'])
    # schedule
    num_iters_per_epoch = math.ceil(len(train_loader) / ds_config["gradient_accumulation_steps"]) #len(train_loader)
    scheduler = make_scheduler(optimizer, cfg['opt'], num_iters_per_epoch)


    model_engine, _, _, _ = deepspeed.initialize(
        model=model,
        model_parameters=parameters,
        optimizer=optimizer,
        lr_scheduler=scheduler,
        config="configs/deepspeed_config.json"
    )

    # enable model EMA
    print("Using model EMA ...")
    model_ema = None # ModelEma(model_engine, device='cuda')

    """4. Resume from model / Misc"""
    # resume from a checkpoint?
    if args.resume:
        if os.path.exists(os.path.join(ckpt_folder, args.resume)):
            # load ckpt, reset epoch / best rmse
            print("Resuming from checkpoint: {:s}".format(args.resume))
            _, client_sd = model_engine.load_checkpoint(
                ckpt_folder,
                args.resume,
                load_optimizer_states=True, 
                load_lr_scheduler_states=True
            )
            args.start_epoch = client_sd['epoch']
        else:
            print("=> no checkpoint found at '{}'".format(args.resume))
            return

    # Initialize the logger
    start_time = datetime.now().strftime("%m-%d_%H-%M")
    logger = TrainingLogger(os.path.join(ckpt_folder, f"training_logs_{start_time}.txt"))

    if args.local_rank == 0:
        # save the current config
        with open(os.path.join(ckpt_folder, 'config.txt'), 'w') as fid:
            pprint.pprint(cfg, stream=fid)
            fid.flush()

        logger.log(pprint.pformat(cfg))

    """4. training / validation loop"""
    print("\nStart training model {:s} ...".format(cfg['model_name']))

    # start training
    max_epochs = cfg['opt'].get(
        'early_stop_epochs',
        cfg['opt']['epochs'] + cfg['opt']['warmup_epochs']
    )
    best_mAP = 0.0
    best_epoch = 0
    for epoch in range(args.start_epoch, max_epochs):
        # train for one epoch
        train_one_epoch(
            train_loader,
            model_engine,
            optimizer,
            scheduler,
            epoch,
            logger,
            model_ema = model_ema,
            clip_grad_l2norm = cfg['train_cfg']['clip_grad_l2norm'],
            print_freq=args.print_freq,
            save_log = args.local_rank == 0
        )

        # save ckpt once in a while
        if (
            ((epoch + 1) == max_epochs) or
            ((args.ckpt_freq > 0) and ((epoch + 1) % args.ckpt_freq == 0))
        ):
            print("Saving model at epoch: ", epoch + 1)
            client_sd = {}
            client_sd['epoch'] = epoch
            model_engine.save_checkpoint(ckpt_folder, tag='epoch_{:03d}'.format(epoch + 1), client_state=client_sd)
            print("Model saved at epoch: ", epoch + 1)

            # set up evaluator
            # train_db_vars = train_dataset.get_attributes()
            # train_eval = ANETdetection(
            #     train_dataset.json_file,
            #     train_dataset.split[0],
            #     tiou_thresholds = train_db_vars['tiou_thresholds']
            # )

            # mAP = valid_one_epoch(
            #     train_loader_for_test,
            #     model_engine,
            #     epoch,
            #     evaluator=train_eval,
            #     print_freq=args.print_freq,
            #     if_save_data=False
            # )
            # if args.local_rank == 0:
            #     print("Epoch: ", epoch, ", Train mAP: ", mAP)
            #     logger.log(f"[Train] Epoch {epoch}: Trainset mAP = {mAP:.4f}")

            ##############################

            val_db_vars = val_dataset.get_attributes()
            det_eval = ANETdetection(
                val_dataset.json_file,
                val_dataset.split[0],
                tiou_thresholds = val_db_vars['tiou_thresholds']
            )

            mAP = valid_one_epoch(
                val_loader,
                model_engine,
                epoch,
                evaluator=det_eval,
                output_file = str(ts),
                print_freq=args.print_freq,
                if_save_data=True
            )
            if args.local_rank == 0:
                print("Epoch: ", epoch, ", Test mAP: ", mAP)
                logger.log(f"[Test] Epoch {epoch}: Testset mAP = {mAP:.4f}")

            # Save the best model
            if mAP > best_mAP:
                best_mAP = mAP
                best_epoch = epoch
                client_sd = {}
                client_sd['epoch'] = epoch
                model_engine.save_checkpoint(ckpt_folder, tag='vit_best_model', client_state=client_sd)
                print("Best model saved at epoch: ", epoch + 1)

    # wrap up
    logger.log(f"Best model saved at epoch {best_epoch}: best testset mAP = {best_mAP:.4f}")
    print("All done!")
    return

################################################################################
if __name__ == '__main__':
    """Entry Point"""
    # the arg parser
    parser = argparse.ArgumentParser(
      description='Train a point-based transformer for action localization')
    parser.add_argument('--config', metavar='DIR', default='./configs/finegym_i3d.yaml', help='path to a config file')
    parser.add_argument('-p', '--print-freq', default=10, type=int, help='print frequency (default: 10 iterations)')
    parser.add_argument('-c', '--ckpt-freq', default=2, type=int, help='checkpoint frequency (default: every 5 epochs)')
    parser.add_argument('--output', default='deepspeed', type=str, help='name of exp folder (default: none)')
    parser.add_argument('--resume', default='', type=str, metavar='PATH', help='path to a checkpoint (default: none)')
    parser.add_argument("--local_rank", default=-1, type=int, help="local_rank for distributed training on gpus")
    args = parser.parse_args()
    print(args.local_rank)

    main(args)
